(define (empty-frame)
  (list))
(define (update frame var val)
  (cons (cons var val) frame))
(define (lookup var frame)
  (assoc var frame))

(define (make-env)
  (list (empty-frame)))
(define (extend-env env)
  (cons (empty-frame) env))
(define (define-var env var val)
  (if (null? env)
      #f
      (set-car! env (update (car env) var val)))
  env)
(define (lookup-var var env)
  (if (null? env)
      #f
      (let ((found (lookup var (car env))))
	(if (pair? found)
	    found
	    (lookup-var var (cdr env))))))

(define (make-closure env params body)
  (cons '*lambda* (cons env (cons params body))))
(define (data-closure? data)
  (if (pair? data) (equal? (car data) '*lambda*) #f))
(define closure-env cadr)
(define closure-params caddr)
(define closure-body cdddr) 

(define (make-primitive arity fun)
  (list '*primitive* arity fun))
(define (data-primitive? data)
  (if (pair? data) (equal? (car data) '*primitive*) #f))
(define primitive-arity cadr)
(define primitive-fun caddr)

(define (print-data data)
  (if (data-closure? data)
      (display "#<closure>")
      (if (data-primitive? data)
	  (display "#<primitive>")
	  (if (equal? data '*unspecified*)
	      (display "#<unspecified>")
	      (if (equal? data '*error*)
		  (display "#<error>")
		  (if (equal? data '*exit*)
		      (display "")
		      (write data)))))))

(define (make-top-env x)
  (let ((env (make-env)))
    (let ((env (define-var env '=
		 (make-primitive 2 (lambda (args env)
				     (cons env (= (car args) (cadr args))))))))
      (let ((env (define-var env '<
		   (make-primitive 2 (lambda (args env)
				       (cons env (< (car args) (cadr args))))))))
	(let ((env (define-var env '>
		     (make-primitive 2 (lambda (args env)
					 (cons env (> (car args) (cadr args))))))))
	  (let ((env (define-var env '+
		       (make-primitive 2 (lambda (args env)
					   (cons env (+ (car args) (cadr args))))))))
	    (let ((env (define-var env '-
			 (make-primitive 2 (lambda (args env)
					     (cons env (- (car args) (cadr args))))))))
	      (let ((env (define-var env '*
			   (make-primitive 2 (lambda (args env)
					       (cons env (* (car args) (cadr args))))))))
		(let ((env (define-var env '/
			     (make-primitive 2 (lambda (args env)
						 (cons env (/ (car args) (cadr args))))))))
		  (let ((env (define-var env 'cons
			       (make-primitive 2 (lambda (args env)
						   (cons env (cons (car args) (cadr args))))))))
		    (let ((env (define-var env 'car
				 (make-primitive 1 (lambda (args env)
						     (cons env (car (car args))))))))
		      (let ((env (define-var env 'cadr
				   (make-primitive 1 (lambda (args env)
						       (cons env (cadr (car args))))))))
			(let ((env (define-var env 'caddr
				     (make-primitive 1 (lambda (args env)
							 (cons env (caddr (car args))))))))
			  (let ((env (define-var env 'cadddr
				       (make-primitive 1 (lambda (args env)
							   (cons env (cadddr (car args))))))))
			    (let ((env (define-var env 'cdr
					 (make-primitive 1 (lambda (args env)
							     (cons env (cdr (car args))))))))
			      (let ((env (define-var env 'cddr
					   (make-primitive 1 (lambda (args env)
							       (cons env (cddr (car args))))))))
				(let ((env (define-var env 'cdddr
					     (make-primitive 1 (lambda (args env)
								 (cons env (cdddr (car args))))))))
				  (let ((env (define-var env 'assoc
					       (make-primitive 2 (lambda (args env)
								   (cons env (assoc (car args) (cadr args))))))))
				    (let ((env (define-var env 'set-car!
						 (make-primitive 2 (lambda (args env)
								     (cons env (set-car! (car args) (cadr args))))))))
				      (let ((env (define-var env 'null?
						   (make-primitive 1 (lambda (args env)
								       (cons env (null? (car args))))))))
					(let ((env (define-var env 'pair?
						     (make-primitive 1 (lambda (args env)
									 (cons env (pair? (car args))))))))
					  (let ((env (define-var env 'boolean?
						       (make-primitive 1 (lambda (args env)
									   (cons env (boolean? (car args))))))))
					    (let ((env (define-var env 'number?
							 (make-primitive 1 (lambda (args env)
									     (cons env (number? (car args))))))))
					      (let ((env (define-var env 'string?
							   (make-primitive 1 (lambda (args env)
									       (cons env (string? (car args))))))))
						(let ((env (define-var env 'equal?
							     (make-primitive 2 (lambda (args env)
										 (cons env (equal? (car args) (cadr args))))))))
						  (let ((env (define-var env 'list?
							       (make-primitive 1 (lambda (args env)
										   (cons env (list? (car args))))))))
						    (let ((env (define-var env 'not
								 (make-primitive 1 (lambda (args env)
										     (cons env (not (car args))))))))
						      (let ((env (define-var env 'display
								   (make-primitive 1 (lambda (args env)
										       (display (car args))
										       (cons env '*unspecified*))))))
							(let ((env (define-var env 'write
								     (make-primitive 1 (lambda (args env)
											 (cons env (write (car args))))))))
							  (let ((env (define-var env 'newline
								       (make-primitive 0 (lambda (args env)
											   (cons env (newline)))))))
							    env))))))))))))))))))))))))))))))

(define (constant? exp)
  (if (boolean? exp) #t (if (number? exp) #t (string? exp))))
(define (var-eval exp env)
  (let ((found (lookup-var exp env)))
    (if (pair? found)
	(cons env (cdr found))
	(eval-error 'unbound-variable exp env))))
(define (eval-error type exp env)
  (begin (display "ERROR: ")
	 (write type)
	 (display ": ")
	 (print-data exp)
	 (newline)
	 (cons env '*error*)))
(define (def-eval exp env)
  (if (list? (cadr exp))
      (base-eval (list 'define (car (cadr exp)) (list 'lambda (cdr (cadr exp)) (caddr exp))) env)
      (let ((var (cadr exp))
	    (res (base-eval (caddr exp) env)))
	(let ((env (car res))
	      (val (cdr res)))
	  (cons (define-var env var val) var)))))
(define (my-map1 f l)
  (if (null? l)
      '()
      (cons (f (car l)) (my-map1 f (cdr l)))))
(define (my-map2 f l1 l2)
  (if (null? l1)
      `()
      (cons (f (car l1) (car l2)) (my-map2 f (cdr l1) (cdr l2)))))
(define (let->app exp)
  (let ((decl (cadr exp))
	(body (cddr exp)))
    (cons (cons 'lambda (cons (my-map1 car decl) body))
	  (my-map1 cadr decl))))
(define (let-eval exp env)
  (base-eval (let->app exp) env))
(define (lambda-eval exp env)
  (cons env (make-closure env (cadr exp) (cddr exp))))
(define (if-eval exp env)
  (if (cdr (base-eval (cadr exp) env))
      (base-eval (caddr exp) env)
      (base-eval (cadddr exp) env)))
(define (list-final l)
  (if (null? (cdr l))
      (car l)
      (list-final (cdr l))))
(define (begin-eval exp env)
  (let ((l (my-map1 (lambda (x) (base-eval x env)) (cdr exp))))
    (list-final l)))
(define (quote-eval exp env)
  (cons env (cadr exp)))
(define (list-eval exp env)
  (cons env (cdr exp)))
(define (read-eval exp env)
  (cons env (read)))
(define (repeat-base-eval el env)
  (cons env
	(my-map1 (lambda (exp) (cdr (base-eval exp env))) el)))
(define (base-apply fun args env)
  (if (data-closure? fun)
      (let ((lenv (extend-env (cadr fun)))
	    (lvar (caddr fun))
	    (lexp (cadddr fun)))
	(begin (my-map2 (lambda (x y) (define-var lenv x y)) lvar args)
	       (cons env 
		     (cdr (base-eval lexp lenv)))))
      (if (data-primitive? fun)
	  (if (if (not (number? (primitive-arity fun)))
		  #t
		  (= (primitive-arity fun) (length args)))
	      ((primitive-fun fun) args env)
	      (eval-error 'wrong-number-of-args fun env))
	  (eval-error 'non-function fun env))))
(define (app-eval exp env)
  (let ((l (repeat-base-eval exp env)))
    (let ((env (car l))
	  (fun (cadr l))
	  (args (cddr l)))
      (base-apply fun args env))))
(define (base-eval exp env)
  (if (eof-object? exp)
      (cons env '*exit*)
      (if (null? exp)
	  (cons env (list))
	  (if (constant? exp)
	      (cons env exp)
	      (if (symbol? exp)
		  (var-eval exp env)
		  (if (not (pair? exp))
		      (eval-error 'non-evaluatable exp env)
		      (if (equal? (car exp) 'exit)
			  (cons env '*exit*)
			  (if (equal? (car exp) 'define)
			      (def-eval exp env)
			      (if (equal? (car exp) 'let)
				  (let-eval exp env) 
				  (if (equal? (car exp) 'lambda)
				      (lambda-eval exp env)
				      (if (equal? (car exp) 'if)
					  (if-eval exp env)
					  (if (equal? (car exp) 'begin)
					      (begin-eval exp env)
					      (if (equal? (car exp) 'quote)
						  (quote-eval exp env)
						  (if (equal? (car exp) 'list) 
						      (list-eval exp env)
						      (if (equal? (car exp) 'read)
							  (read-eval exp env)
							  (app-eval exp env))))))))))))))))

(define (rep-loop env)
  (begin (display "> ")
	 (let ((res (base-eval (my-read 1) env)))
	   (let ((env (car res))
		 (val (cdr res)))
	     (begin (print-data val)
		    (newline)
		    (if (equal? val '*exit*)
			#t
			(rep-loop env)))))))
(define (scheme)
  (let ((top-env (make-top-env 1)))
    (rep-loop top-env)))
